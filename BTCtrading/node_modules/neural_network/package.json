{
  "name": "neural_network",
  "version": "0.2.5",
  "description": "Neural network implementation with backpropagation. It uses map reduce to distribute the computation of cost function and it's gradients. It also implements stochastic/step/batch gradient descent for optimizing cost function",
  "main": "neural_network.js",
  "files": [
    "neural_network.js",
    "helpers",
    "tests"
  ],
  "dependencies": {
    "compute-cluster": "~0.0.7",
    "knuth-shuffle": "~1.0.0",
    "lodash": "~2.4.1"
  },
  "devDependencies": {
    "chai": "^1.9.2",
    "compute-cluster": "0.0.7",
    "knuth-shuffle": "~1.0.0",
    "lodash": "~2.4.1",
    "mocha": "^1.21.4"
  },
  "scripts": {
    "test": "node tests/numericGradientTest.js; node tests/train.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/pallogu/NodeNeuralNetwork.git"
  },
  "keywords": [
    "nodejs",
    "neural network",
    "big data",
    "machine learning"
  ],
  "author": {
    "name": "Paul Gustafik"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/pallogu/NodeNeuralNetwork/issues"
  },
  "homepage": "https://github.com/pallogu/NodeNeuralNetwork",
  "readme": "#Nodejs Neural Network\n##Description\nThis is a nodejs implementation of dense neural network with two hidden layer and one category output layer.\n\nIt uses [compute cluster](https://github.com/lloyd/node-compute-cluster) for splitting the work into multiple cores.\n\nFor cost function optimisation, one can use batch/mini-batches/stochastic gradient descent.\n\nFor mini-batches and stochastic gradient descent it randomises training examples using (knuth-shuffle)[https://github.com/coolaj86/knuth-shuffle]\n\n##Instalation\n\nInstall from command line\n\n`$ npm install neural_network`\n\n##Examples\n\n\tvar NeuralNetwork = require('neural_network');\n\tvar nn = new NeuralNetwork();\n\t\n\tvar trainingSetInput = [\n\t    [0,0],\n\t    [0,1],\n\t    [1,0],\n\t    [1,1]\n\t];\n\t\n\tvar trainingSetOutput = [\n\t    [0],\n\t    [1],\n    \t[1],\n\t    [0]\n\t];\n\t\n\tvar setup = {\n\t    trainingSetInput: trainingSetInput,\n\t    trainingSetOutput: trainingSetOutput,\n\t    numberOfActivationUnitsL1: 4,\n\t    numberOfActivationUnitsL2: 4,\n\t    numberOfNodes: 1,\n\t    numberOfExamplesPerNode: 4,\n\t    learningRate: 0.5,\n\t    maxCostError: 0.001,\n\t    maxNoOfIterations: 100000\n\t}\n\t\n\tnn.train(setup, function (err, model) {\n\t    nn.predict([1,1], function (err, probability){\n\t        console.log('probability that y would be \tpositive', probability);\n\t        nn.exit();\n\t    });\n\t});\n\n## Setup\n\nSetup takes following required parameters\n\n* trainingSetX: Please use matrix representation\n* trainingSetY: Please use matrix representation\n* numberOfActivationUnitsL1: Number of activation units in first hidden layer\n* numberOfActivationUnitsL2: Number of activation units in second hidden layer\n\nFollowing parameters are optional\n\n* numberOfNodes: (int) Used for map reduce\n* numberOfExamplesPerNode: (int)\n* learningRate: (number) This number is used in gradient descent\n* lambda: (number) regularisation parameter\n* maxCostError: (number) This parameter is used to stop training. If the value of cost function is less than maxCostError callback will be called\n* maxGradientSize: (number) This parameter is used also to stop training. If the gradient size is smaller than this value, there is a check of whether secondary derivations are positive (diagonal of Hessian)\n* maxNoOfIterations: (int) This parameter is used to stop training. The default value is Number.MAX_VALUE\n* model: (array) This is the starting point for gradient descent optimisation. If you do not provide this one will be randomly generated. This is useful if you already have a model and want to adjust it by new examples. The *train* method calls the callback with trained model as parameter.\n* verboseMode: (boolean) If set to true it will report the progress of learning\n\n\n\n##Optimisation\n\n### Stochastic gradient descent\nSet:\n\t\n\tnumberOfNodes = 1\n\tnumberOfExamplesPerNode = 1\n\t\n### Batch gradient descent\n\nSet:\n\n\tvar os = require(os);\n\t\n\tnumberOfNodes = os.cpus().length - 1;\n\tnumberOfExamples = Math.floor(trainingSetX.length / numberOfNodes);\n\t\n### Mini batch gradient descent\n\nSet for example:\n\n\tvar os = require(os);\n\t\n\tnumberOfNodes = os.cpus().length - 1;\n\tnumberOfExamples = 10;\n\n\n## Some implementation notes\n\nIn other words you have to find a balance between numberOfExamplesPerNode and numberOfNodes for mini batch gradient descent.\n\n## Copyright\n\nCopyright (c) 2014, Paul Gustafik paul.gustafik@gmail.com\n\nPermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n",
  "readmeFilename": "Readme.md",
  "_id": "neural_network@0.2.5",
  "dist": {
    "shasum": "0b05cca99fb6050ba7a88ff5560ed05be165ba76"
  },
  "_from": "neural_network@",
  "_resolved": "https://registry.npmjs.org/neural_network/-/neural_network-0.2.5.tgz"
}
